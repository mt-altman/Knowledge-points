<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elasticsearch DSL查询之复合查询详解</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        :root {
            --primary-color: #007C89;
            --secondary-color: #52BBD3;
            --accent-color: #F16A43;
            --background-color: #F8F9FA;
            --text-color: #333333;
            --sidebar-width: 280px;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: var(--text-color);
            background-color: var(--background-color);
            line-height: 1.6;
        }
        .sidebar {
            background-color: white;
            width: var(--sidebar-width);
            position: fixed;
            height: 100vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
            border-right: 1px solid #e5e7eb;
        }
        .content {
            margin-left: var(--sidebar-width);
            padding: 2rem;
            max-width: calc(100% - var(--sidebar-width));
        }
        .toc-link {
            display: block;
            padding: 0.5rem 1rem;
            color: var(--text-color);
            text-decoration: none;
            border-left: 3px solid transparent;
        }
        .toc-link:hover, .toc-link.active {
            background-color: rgba(0, 124, 137, 0.1);
            border-left-color: var(--primary-color);
        }
        .toc-link.level-2 {
            padding-left: 2rem;
            font-size: 0.95rem;
        }
        .toc-link.level-3 {
            padding-left: 3rem;
            font-size: 0.9rem;
        }
        pre {
            background-color: #f1f5f9;
            border-radius: 0.5rem;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.9em;
        }
        .toggle-sidebar {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 50;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 0.25rem;
            padding: 0.5rem;
        }
        .note {
            background-color: #e8f4f8;
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 0.25rem 0.25rem 0;
        }
        .warning {
            background-color: #fff3e0;
            border-left: 4px solid var(--accent-color);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 0.25rem 0.25rem 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        th, td {
            border: 1px solid #e5e7eb;
            padding: 0.75rem;
            text-align: left;
        }
        th {
            background-color: #f1f5f9;
        }
        tr:nth-child(even) {
            background-color: #f8fafc;
        }
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                z-index: 40;
            }
            .sidebar.open {
                transform: translateX(0);
            }
            .content {
                margin-left: 0;
                max-width: 100%;
                padding: 1rem;
                padding-top: 4rem;
            }
            .toggle-sidebar {
                display: block;
            }
        }
    /* 返回首页按钮样式 */
        .home-button-fixed {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background-color: #3498db;
            color: white;
            border-radius: 50%;
            text-decoration: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: background-color 0.3s, transform 0.2s;
        }
        .home-button-fixed:hover {
            background-color: #2980b9;
            transform: translateY(-50%) translateX(2px);
        }
        .home-button-fixed svg {
            width: 20px;
            height: 20px;
        }
        @media (max-width: 768px) {
            .home-button-fixed {
                top: 50%;
                left: 10px;
                width: 36px;
                height: 36px;
            }
            .home-button-fixed svg {
                width: 18px;
                height: 18px;
            }
        }</style>
</head>
<body class="bg-gray-50"><a href="../index.html" class="home-button-fixed" title="返回首页"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg></a>
    <button class="toggle-sidebar" onclick="toggleSidebar()">
        <i class="fas fa-bars"></i>
    </button>
    
    <div class="sidebar shadow-md" id="sidebar">
        <div class="p-4 bg-gradient-to-r from-cyan-700 to-cyan-600 text-white">
            <h2 class="text-xl font-bold">Elasticsearch 学习指南</h2>
        </div>
        <nav class="py-4">
            <a href="#introduction" class="toc-link level-1"><i class="fas fa-book-open mr-2"></i> 1. 复合查询简介</a>
            <a href="#bool-query" class="toc-link level-1"><i class="fas fa-code-branch mr-2"></i> 2. Bool 查询</a>
            <a href="#bool-clauses" class="toc-link level-2">2.1 Bool 查询子句</a>
            <a href="#bool-examples" class="toc-link level-2">2.2 Bool 查询示例</a>
            <a href="#bool-score" class="toc-link level-2">2.3 Bool 查询评分机制</a>
            <a href="#bool-best-practices" class="toc-link level-2">2.4 Bool 查询最佳实践</a>
            <a href="#boosting-query" class="toc-link level-1"><i class="fas fa-sort-amount-up mr-2"></i> 3. Boosting 查询</a>
            <a href="#boosting-examples" class="toc-link level-2">3.1 Boosting 查询示例</a>
            <a href="#constant-score" class="toc-link level-1"><i class="fas fa-equals mr-2"></i> 4. Constant Score 查询</a>
            <a href="#constant-score-examples" class="toc-link level-2">4.1 Constant Score 查询示例</a>
            <a href="#dis-max" class="toc-link level-1"><i class="fas fa-layer-group mr-2"></i> 5. Dis Max 查询</a>
            <a href="#dis-max-examples" class="toc-link level-2">5.1 Dis Max 查询示例</a>
            <a href="#function-score" class="toc-link level-1"><i class="fas fa-calculator mr-2"></i> 6. Function Score 查询</a>
            <a href="#function-score-components" class="toc-link level-2">6.1 Function Score 组件</a>
            <a href="#function-score-examples" class="toc-link level-2">6.2 Function Score 示例</a>
            <a href="#nested-query" class="toc-link level-1"><i class="fas fa-sitemap mr-2"></i> 7. Nested 查询</a>
            <a href="#nested-examples" class="toc-link level-2">7.1 Nested 查询示例</a>
            <a href="#comparison" class="toc-link level-1"><i class="fas fa-balance-scale mr-2"></i> 8. 复合查询对比</a>
            <a href="#performance" class="toc-link level-1"><i class="fas fa-tachometer-alt mr-2"></i> 9. 性能考量</a>
            <a href="#conclusion" class="toc-link level-1"><i class="fas fa-flag-checkered mr-2"></i> 10. 总结</a>
        </nav>
    </div>

    <div class="content bg-white shadow-md rounded-lg" id="content">
        <h1 class="text-3xl font-bold mb-6 text-cyan-700 border-b pb-2"><i class="fas fa-cubes mr-2"></i>Elasticsearch DSL查询之复合查询详解</h1>
        
        <section id="introduction" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-book-open mr-2"></i>1. 复合查询简介</h2>
            <p class="mb-4">
                Elasticsearch 的复合查询（Compound Queries）是一种强大的查询机制，允许我们将多个查询组合在一起形成更复杂的查询逻辑。复合查询在实际应用中非常重要，因为它们能够满足各种复杂的业务需求，如多条件筛选、权重调整、嵌套文档查询等。
            </p>
            
            <div class="mermaid my-6">
graph TD
    A[复合查询 Compound Queries] --> B[Bool 查询]
    A --> C[Boosting 查询]
    A --> D[Constant Score 查询]
    A --> E[Dis Max 查询]
    A --> F[Function Score 查询]
    A --> G[Nested 查询]
    
    B --> B1[must]
    B --> B2[should]
    B --> B3[must_not]
    B --> B4[filter]
    
    F --> F1[functions]
    F --> F2[query]
    F --> F3[score_mode]
    F --> F4[boost_mode]
            </div>
            
            <p class="mb-4">
                在本文中，我们将详细介绍 Elasticsearch 中的各种复合查询类型，包括它们的语法、使用场景、工作原理以及最佳实践。通过掌握这些复合查询，你将能够构建出更加精确和高效的搜索解决方案。
            </p>
        </section>
        
        <section id="bool-query" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-code-branch mr-2"></i>2. Bool 查询</h2>
            <p class="mb-4">
                Bool 查询是 Elasticsearch 中最常用的复合查询类型，它使用布尔逻辑将多个查询子句组合在一起。Bool 查询的灵感来源于 Lucene 的 BooleanQuery，它允许我们通过 must、should、must_not 和 filter 四种子句来组合多个查询条件。
            </p>
            
            <div id="bool-clauses" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">2.1 Bool 查询子句</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th>子句类型</th>
                            <th>描述</th>
                            <th>影响评分</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>must</code></td>
                            <td>文档必须匹配这些条件，类似于 AND 操作</td>
                            <td>是</td>
                        </tr>
                        <tr>
                            <td><code>should</code></td>
                            <td>文档应该匹配这些条件，类似于 OR 操作</td>
                            <td>是</td>
                        </tr>
                        <tr>
                            <td><code>must_not</code></td>
                            <td>文档必须不匹配这些条件，类似于 NOT 操作</td>
                            <td>否</td>
                        </tr>
                        <tr>
                            <td><code>filter</code></td>
                            <td>文档必须匹配这些条件，但不影响评分</td>
                            <td>否</td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="note mt-4">
                    <p><strong><i class="fas fa-info-circle mr-1"></i> 注意：</strong> Bool 查询的行为会根据是否存在 should 子句而有所不同：</p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>如果没有 must 或 filter 子句，则至少需要匹配一个 should 子句</li>
                        <li>如果存在 must 或 filter 子句，则 should 子句变为可选，但匹配 should 子句会提高文档的相关性评分</li>
                        <li>可以通过 <code>minimum_should_match</code> 参数控制至少需要匹配的 should 子句数量</li>
                    </ul>
                </div>
            </div>
            
            <div id="bool-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">2.2 Bool 查询示例</h3>
                <p class="mb-3">以下是一个综合的 Bool 查询示例，它结合了所有四种子句类型：</p>
                
                <pre><code>{
  "query": {
    "bool": {
      "must": [
        { "match": { "title": "elasticsearch" } },
        { "range": { "publish_date": { "gte": "2020-01-01" } } }
      ],
      "should": [
        { "match": { "description": "search engine" } },
        { "match": { "category": "technology" } }
      ],
      "must_not": [
        { "term": { "status": "draft" } }
      ],
      "filter": [
        { "term": { "is_published": true } }
      ],
      "minimum_should_match": 1
    }
  }
}</code></pre>
                
                <p class="mt-3">这个查询的含义是：</p>
                <ul class="list-disc pl-6 mt-2">
                    <li>文档的标题必须包含 "elasticsearch"</li>
                    <li>文档的发布日期必须大于等于 2020-01-01</li>
                    <li>文档的描述最好包含 "search engine" 或类别最好是 "technology"（至少匹配其中一个）</li>
                    <li>文档的状态不能是 "draft"</li>
                    <li>文档必须已发布（is_published 为 true）</li>
                </ul>
            </div>
            
            <div id="bool-score" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">2.3 Bool 查询评分机制</h3>
                <p class="mb-3">
                    Bool 查询的评分机制是理解其工作原理的关键。以下是 Bool 查询评分的基本规则：
                </p>
                
                <ol class="list-decimal pl-6 mb-4">
                    <li>must 和 should 子句会影响文档的相关性评分</li>
                    <li>must_not 和 filter 子句仅用于过滤文档，不影响评分</li>
                    <li>最终评分是所有匹配的 must 和 should 子句的评分总和</li>
                </ol>
                
                <div class="mermaid my-6">
graph LR
    A[文档] --> B{Bool查询}
    B --> C[must子句]
    B --> D[should子句]
    B --> E[must_not子句]
    B --> F[filter子句]
    
    C --> G[影响评分]
    D --> G
    E --> H[不影响评分]
    F --> H
    
    G --> I[最终评分]
    H --> J[文档过滤]
    
    I --> K[结果文档]
    J --> K
                </div>
                
                <p class="mb-3">
                    使用 filter 子句而不是 must 子句可以提高查询性能，因为 filter 查询可以被缓存，并且跳过了评分计算的步骤。在不需要考虑相关性评分的场景下，应优先使用 filter。
                </p>
            </div>
            
            <div id="bool-best-practices" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">2.4 Bool 查询最佳实践</h3>
                <ul class="list-disc pl-6">
                    <li class="mb-2"><strong>合理使用 filter 和 must：</strong> 对于不需要影响评分的条件，使用 filter 而不是 must，这样可以提高查询性能</li>
                    <li class="mb-2"><strong>控制 should 子句数量：</strong> 过多的 should 子句会影响性能，考虑使用 dis_max 查询替代</li>
                    <li class="mb-2"><strong>嵌套 Bool 查询：</strong> Bool 查询可以嵌套，但嵌套层次过深会使查询难以维护和理解</li>
                    <li class="mb-2"><strong>使用 minimum_should_match：</strong> 合理设置 minimum_should_match 参数可以提高搜索结果的质量</li>
                    <li class="mb-2"><strong>注意查询顺序：</strong> 将可能过滤掉更多文档的条件放在前面，可以提高查询效率</li>
                </ul>
            </div>
        </section>
        
        <section id="boosting-query" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-sort-amount-up mr-2"></i>3. Boosting 查询</h2>
            <p class="mb-4">
                Boosting 查询是一种特殊的复合查询，它允许我们降低某些文档的相关性评分，而不是完全排除它们。Boosting 查询包含两部分：positive 查询和 negative 查询。
            </p>
            
            <ul class="list-disc pl-6 mb-4">
                <li><strong>positive 查询：</strong> 返回的文档必须匹配这个查询</li>
                <li><strong>negative 查询：</strong> 匹配这个查询的文档会被降低评分</li>
                <li><strong>negative_boost：</strong> 一个0到1之间的浮点数，用于降低匹配 negative 查询的文档的评分</li>
            </ul>
            
            <div class="mermaid my-6">
graph TD
    A[Boosting查询] --> B[positive查询]
    A --> C[negative查询]
    A --> D[negative_boost参数]
    
    B --> E[必须匹配]
    C --> F[降低评分]
    D --> F
    
    E --> G[结果文档]
    F --> G
            </div>
            
            <div id="boosting-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">3.1 Boosting 查询示例</h3>
                <p class="mb-3">假设我们想要搜索关于"苹果"的文档，但希望降低那些主要讨论"苹果手机"的文档的相关性：</p>
                
                <pre><code>{
  "query": {
    "boosting": {
      "positive": {
        "match": {
          "content": "苹果"
        }
      },
      "negative": {
        "match": {
          "content": "手机"
        }
      },
      "negative_boost": 0.5
    }
  }
}</code></pre>
                
                <p class="mt-3">
                    在这个例子中，所有包含"苹果"的文档都会被返回，但如果文档同时包含"手机"，则其评分会被乘以0.5，从而降低其在结果中的排名。
                </p>
                
                <div class="note mt-4">
                    <p><strong><i class="fas fa-lightbulb mr-1"></i> 使用场景：</strong> Boosting 查询特别适用于以下场景：</p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>需要降低某些文档的相关性，但不想完全排除它们</li>
                        <li>实现"软否定"（soft not）逻辑，与 must_not 的"硬否定"相对</li>
                        <li>处理搜索结果中的偏好调整，如降低某些类别或特定属性的文档的权重</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <section id="constant-score" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-equals mr-2"></i>4. Constant Score 查询</h2>
            <p class="mb-4">
                Constant Score 查询将一个查询包装起来，并为所有匹配的文档分配一个固定的评分。这种查询类型主要用于性能优化，特别是当我们只关心文档是否匹配，而不关心它们的相对相关性时。
            </p>
            
            <p class="mb-4">
                Constant Score 查询有两个主要组件：
            </p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>filter：</strong> 用于筛选文档的查询</li>
                <li><strong>boost：</strong> 分配给所有匹配文档的固定评分值（默认为1.0）</li>
            </ul>
            
            <div id="constant-score-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">4.1 Constant Score 查询示例</h3>
                <p class="mb-3">以下是一个 Constant Score 查询的示例：</p>
                
                <pre><code>{
  "query": {
    "constant_score": {
      "filter": {
        "term": {
          "category": "electronics"
        }
      },
      "boost": 1.2
    }
  }
}</code></pre>
                
                <p class="mt-3">
                    这个查询会返回所有 category 字段包含 "electronics" 的文档，并为它们分配一个固定的评分 1.2。
                </p>
                
                <div class="warning mt-4">
                    <p><strong><i class="fas fa-exclamation-triangle mr-1"></i> 性能提示：</strong></p>
                    <p class="mt-2">
                        Constant Score 查询是一种性能优化技术，因为它跳过了评分计算的步骤。当你只需要过滤文档而不关心它们的相对相关性时，使用 Constant Score 查询可以显著提高查询性能。
                    </p>
                </div>
                
                <p class="mt-3">
                    Constant Score 查询与 Bool 查询的 filter 子句在功能上类似，但它提供了一种更直接的方式来应用固定评分。在实际应用中，如果你需要组合多个过滤条件，Bool 查询可能更合适；而如果只有单个过滤条件，Constant Score 查询可能是更简洁的选择。
                </p>
            </div>
        </section>
        
        <section id="dis-max" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-layer-group mr-2"></i>5. Dis Max 查询</h2>
            <p class="mb-4">
                Dis Max（Disjunction Max）查询是一种特殊的复合查询，它返回匹配任何查询的文档，但只使用最佳匹配查询的评分作为文档的最终评分。这与 Bool 查询的 should 子句不同，后者会将所有匹配查询的评分相加。
            </p>
            
            <p class="mb-4">
                Dis Max 查询的主要组件包括：
            </p>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>queries：</strong> 一组查询，文档只需匹配其中任何一个</li>
                <li><strong>tie_breaker：</strong> 一个0到1之间的浮点数，用于调整其他匹配查询对最终评分的贡献</li>
            </ul>
            
            <div class="mermaid my-6">
graph TD
    A[Dis Max查询] --> B[queries数组]
    A --> C[tie_breaker参数]
    
    B --> D[查询1]
    B --> E[查询2]
    B --> F[查询3]
    
    D --> G[评分1]
    E --> H[评分2]
    F --> I[评分3]
    
    G --> J{选择最高评分}
    H --> J
    I --> J
    
    C --> K[其他查询评分贡献]
    
    J --> L[最终评分]
    K --> L
            </div>
            
            <div id="dis-max-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">5.1 Dis Max 查询示例</h3>
                <p class="mb-3">假设我们想要搜索在标题、内容或标签中包含"elasticsearch"的文档：</p>
                
                <pre><code>{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "title": "elasticsearch" } },
        { "match": { "content": "elasticsearch" } },
        { "match": { "tags": "elasticsearch" } }
      ],
      "tie_breaker": 0.3
    }
  }
}</code></pre>
                
                <p class="mt-3">
                    在这个例子中，如果一个文档在多个字段中匹配"elasticsearch"，其最终评分将是：
                </p>
                <p class="mb-3 pl-4">
                    最终评分 = 最高字段评分 + (其他匹配字段评分 × tie_breaker)
                </p>
                
                <div class="note mt-4">
                    <p><strong><i class="fas fa-lightbulb mr-1"></i> 使用场景：</strong></p>
                    <p class="mt-2">
                        Dis Max 查询特别适用于以下场景：
                    </p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>多字段搜索，当匹配某一字段比匹配多个字段更重要时</li>
                        <li>当你希望避免多字段匹配导致的评分膨胀问题</li>
                        <li>实现"最佳字段"（best fields）搜索策略</li>
                    </ul>
                </div>
                
                <p class="mt-3">
                    <strong>tie_breaker 参数的作用：</strong>
                </p>
                <ul class="list-disc pl-6 mt-2">
                    <li>当 tie_breaker = 0 时，只考虑最佳匹配查询的评分</li>
                    <li>当 tie_breaker = 1 时，所有匹配查询的评分都会被完全考虑（类似于 Bool 查询的 should）</li>
                    <li>当 0 < tie_breaker < 1 时，其他匹配查询的评分会按比例贡献到最终评分</li>
                </ul>
            </div>
        </section>
        
        <section id="function-score" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-calculator mr-2"></i>6. Function Score 查询</h2>
            <p class="mb-4">
                Function Score 查询是 Elasticsearch 中最强大和灵活的复合查询之一，它允许我们通过自定义函数修改查询返回的文档评分。这种查询类型特别适用于实现个性化排序、业务规则干预、衰减函数等高级排序需求。
            </p>
            
            <div id="function-score-components" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">6.1 Function Score 组件</h3>
                <p class="mb-3">Function Score 查询由以下几个主要组件组成：</p>
                
                <ul class="list-disc pl-6 mb-4">
                    <li><strong>query：</strong> 基础查询，用于筛选初始文档集</li>
                    <li><strong>functions：</strong> 一组评分函数，用于修改文档的原始评分</li>
                    <li><strong>score_mode：</strong> 定义如何组合多个函数的评分结果（可选值：multiply, sum, avg, first, max, min）</li>
                    <li><strong>boost_mode：</strong> 定义如何将函数评分与原始查询评分组合（可选值：multiply, replace, sum, avg, max, min）</li>
                    <li><strong>min_score：</strong> 设置结果文档的最小评分阈值</li>
                    <li><strong>max_boost：</strong> 限制函数给评分带来的最大提升</li>
                </ul>
                
                <p class="mb-3">Function Score 支持的函数类型包括：</p>
                <table class="w-full border-collapse">
                    <thead>
                        <tr>
                            <th>函数类型</th>
                            <th>描述</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>weight</code></td>
                            <td>对所有文档应用一个简单的权重</td>
                        </tr>
                        <tr>
                            <td><code>field_value_factor</code></td>
                            <td>使用字段的值来影响评分</td>
                        </tr>
                        <tr>
                            <td><code>random_score</code></td>
                            <td>生成随机评分，可用于结果随机化</td>
                        </tr>
                        <tr>
                            <td><code>decay functions</code><br/>(gauss, exp, linear)</td>
                            <td>基于数值字段（如日期、数字或地理位置）的衰减函数</td>
                        </tr>
                        <tr>
                            <td><code>script_score</code></td>
                            <td>使用自定义脚本计算评分</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <div class="mermaid my-6">
graph TD
    A[Function Score查询] --> B[基础查询]
    A --> C[评分函数]
    A --> D[组合模式]
    
    C --> E[weight]
    C --> F[field_value_factor]
    C --> G[random_score]
    C --> H[decay functions]
    C --> I[script_score]
    
    D --> J[score_mode]
    D --> K[boost_mode]
    
    B --> L[初始文档集]
    C --> M[修改评分]
    
    L --> N[最终排序结果]
    M --> N
            </div>
            
            <div id="function-score-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">6.2 Function Score 示例</h3>
                <p class="mb-3">以下是几个 Function Score 查询的示例：</p>
                
                <h4 class="font-bold mt-4 mb-2">示例 1：使用 field_value_factor 基于字段值调整评分</h4>
                <pre><code>{
  "query": {
    "function_score": {
      "query": { "match": { "title": "elasticsearch" } },
      "field_value_factor": {
        "field": "popularity",
        "factor": 1.2,
        "modifier": "log1p",
        "missing": 1
      },
      "boost_mode": "multiply"
    }
  }
}</code></pre>
                
                <p class="mt-2 mb-4">
                    这个查询会根据文档的 popularity 字段值调整评分，使用 log1p 修饰符减少极值的影响，并将结果与原始评分相乘。
                </p>
                
                <h4 class="font-bold mt-4 mb-2">示例 2：使用衰减函数根据日期降低评分</h4>
                <pre><code>{
  "query": {
    "function_score": {
      "query": { "match_all": {} },
      "functions": [
        {
          "gauss": {
            "publish_date": {
              "origin": "now",
              "scale": "30d",
              "decay": 0.5
            }
          }
        }
      ]
    }
  }
}</code></pre>
                
                <p class="mt-2 mb-4">
                    这个查询使用高斯衰减函数，使较新的文档获得更高的评分，而较旧的文档评分逐渐降低。
                </p>
                
                <h4 class="font-bold mt-4 mb-2">示例 3：组合多个函数</h4>
                <pre><code>{
  "query": {
    "function_score": {
      "query": { "match": { "content": "技术博客" } },
      "functions": [
        {
          "filter": { "term": { "premium": true } },
          "weight": 2
        },
        {
          "filter": { "term": { "featured": true } },
          "weight": 1.5
        },
        {
          "field_value_factor": {
            "field": "views",
            "modifier": "log1p",
            "factor": 0.1
          }
        }
      ],
      "score_mode": "sum",
      "boost_mode": "multiply",
      "min_score": 1.0
    }
  }
}</code></pre>
                
                <p class="mt-2">
                    这个查询结合了多个评分函数：
                </p>
                <ul class="list-disc pl-6 mt-2">
                    <li>增加高级（premium）内容的权重</li>
                    <li>增加精选（featured）内容的权重</li>
                    <li>根据浏览量（views）调整评分</li>
                </ul>
                <p class="mt-2">
                    所有函数的评分会被相加（score_mode: sum），然后与原始查询评分相乘（boost_mode: multiply）。
                </p>
                
                <div class="note mt-4">
                    <p><strong><i class="fas fa-lightbulb mr-1"></i> 使用场景：</strong></p>
                    <ul class="list-disc pl-6 mt-2">
                        <li>电商网站中基于销量、评分、上架时间等因素的商品排序</li>
                        <li>新闻网站中考虑文章时效性的搜索结果排序</li>
                        <li>实现基于用户行为的个性化搜索结果</li>
                        <li>基于地理位置的附近搜索，距离越近评分越高</li>
                        <li>实现业务规则干预，如提升特定标签或类别的内容</li>
                    </ul>
                </div>
            </div>
        </section>
        
        <section id="nested-query" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-sitemap mr-2"></i>7. Nested 查询</h2>
            <p class="mb-4">
                Nested 查询专门用于搜索嵌套类型的字段。在 Elasticsearch 中，嵌套对象是一种特殊的数据类型，允许将数组中的对象作为独立的实体进行索引和查询，从而保持对象内部字段之间的关系。
            </p>
            
            <p class="mb-4">
                当我们在处理包含对象数组的文档时，如果需要基于数组中对象的多个字段进行查询，就需要使用 Nested 查询。
            </p>
            
            <div class="warning mb-4">
                <p><strong><i class="fas fa-exclamation-triangle mr-1"></i> 重要提示：</strong></p>
                <p class="mt-2">
                    要使用 Nested 查询，相关字段必须在映射中被定义为 <code>nested</code> 类型。使用普通的对象类型会导致对象结构被扁平化，从而无法保持字段间的关系。
                </p>
            </div>
            
            <div class="mb-4">
                <h4 class="font-bold mb-2">嵌套查询的主要组件：</h4>
                <ul class="list-disc pl-6">
                    <li><strong>path：</strong> 指定嵌套对象的路径</li>
                    <li><strong>query：</strong> 应用于嵌套对象的查询</li>
                    <li><strong>score_mode：</strong> 定义如何计算嵌套查询的评分（可选值：avg, sum, min, max, none）</li>
                    <li><strong>ignore_unmapped：</strong> 如果设置为 true，则忽略未映射字段而不是抛出异常</li>
                </ul>
            </div>
            
            <div id="nested-examples" class="mb-6">
                <h3 class="text-xl font-bold mb-3 text-cyan-500">7.1 Nested 查询示例</h3>
                
                <p class="mb-3">假设我们有以下文档结构，其中 comments 是一个嵌套类型的字段：</p>
                
                <pre><code>{
  "title": "Elasticsearch 实战指南",
  "content": "这是一本关于 Elasticsearch 的书...",
  "comments": [
    {
      "user": "alice",
      "rating": 5,
      "text": "非常实用的书"
    },
    {
      "user": "bob",
      "rating": 4,
      "text": "内容全面，讲解清晰"
    }
  ]
}</code></pre>
                
                <p class="mt-3 mb-3">下面的查询示例会查找包含由 "alice" 评分为 5 分的评论的文档：</p>
                
                <pre><code>{
  "query": {
    "nested": {
      "path": "comments",
      "query": {
        "bool": {
          "must": [
            { "match": { "comments.user": "alice" } },
            { "term": { "comments.rating": 5 } }
          ]
        }
      },
      "score_mode": "avg"
    }
  }
}</code></pre>
                
                <div class="note mt-4">
                    <p><strong><i class="fas fa-info-circle mr-1"></i> 嵌套查询与对象查询的区别：</strong></p>
                    <p class="mt-2">
                        在标准对象查询中，对象数组会被扁平化，导致字段间的关系丢失。例如，上面的示例如果不使用嵌套类型，可能会错误地匹配评论用户是 "alice" 且任何评分为 5 的文档，即使该 5 分评分来自另一个用户。
                    </p>
                    <p class="mt-2">
                        嵌套查询通过维护嵌套对象的完整性，确保查询条件在同一个嵌套对象内部评估，从而保持字段之间的关系。
                    </p>
                </div>
                
                <h4 class="font-bold mt-4 mb-2">与其他查询结合使用</h4>
                <p class="mb-3">
                    嵌套查询通常与其他查询类型结合使用，特别是 Bool 查询，以实现更复杂的查询逻辑：
                </p>
                
                <pre><code>{
  "query": {
    "bool": {
      "must": [
        { "match": { "title": "elasticsearch" } },
        {
          "nested": {
            "path": "comments",
            "query": {
              "bool": {
                "must": [
                  { "range": { "comments.rating": { "gte": 4 } } }
                ]
              }
            }
          }
        }
      ]
    }
  }
}</code></pre>
                
                <p class="mt-3">
                    这个查询会查找标题包含 "elasticsearch" 且至少有一条评分大于等于 4 的评论的文档。
                </p>
                
                <div class="warning mt-4">
                    <p><strong><i class="fas fa-exclamation-triangle mr-1"></i> 性能注意事项：</strong></p>
                    <p class="mt-2">
                        嵌套查询比普通查询更消耗资源，因为每个嵌套文档都会被单独索引。在设计数据模型时，应该权衡使用嵌套类型的好处与性能影响。如果嵌套文档数量很大，可能需要考虑使用父子关系或者分离索引。
                    </p>
                </div>
            </div>
        </section>
        
        <section id="comparison" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-balance-scale mr-2"></i>8. 复合查询对比</h2>
            <p class="mb-4">
                各种复合查询类型有不同的特点和适用场景，下面是它们之间的对比：
            </p>
            
            <table class="w-full border-collapse">
                <thead>
                    <tr>
                        <th>查询类型</th>
                        <th>特点</th>
                        <th>适用场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Bool 查询</strong></td>
                        <td>组合多个查询条件，使用布尔逻辑</td>
                        <td>多条件筛选，复杂查询逻辑，需要同时满足多个条件</td>
                    </tr>
                    <tr>
                        <td><strong>Boosting 查询</strong></td>
                        <td>降低某些文档的相关性评分</td>
                        <td>需要降低但不排除某类文档的场景，如降低包含特定词汇的文档权重</td>
                    </tr>
                    <tr>
                        <td><strong>Constant Score 查询</strong></td>
                        <td>为所有匹配文档分配固定评分</td>
                        <td>只关心文档是否匹配而不关心相对相关性的场景，过滤查询</td>
                    </tr>
                    <tr>
                        <td><strong>Dis Max 查询</strong></td>
                        <td>使用最佳匹配查询的评分作为最终评分</td>
                        <td>多字段搜索，当匹配任何一个字段就足够的场景，避免多字段匹配导致的评分膨胀</td>
                    </tr>
                    <tr>
                        <td><strong>Function Score 查询</strong></td>
                        <td>通过自定义函数修改评分</td>
                        <td>复杂的评分需求，个性化排序，业务规则干预，时效性排序</td>
                    </tr>
                    <tr>
                        <td><strong>Nested 查询</strong></td>
                        <td>查询嵌套对象数组内的字段</td>
                        <td>处理嵌套对象数据，保持对象内部字段之间的关系</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="mermaid my-6">
graph TD
    A[复合查询选择] --> B{需要嵌套对象查询?}
    B -->|是| C[Nested查询]
    B -->|否| D{需要自定义评分?}
    
    D -->|是| E[Function Score查询]
    D -->|否| F{关注多个字段的最佳匹配?}
    
    F -->|是| G[Dis Max查询]
    F -->|否| H{只需过滤文档?}
    
    H -->|是| I[Constant Score查询]
    H -->|否| J{需要降低某些文档评分?}
    
    J -->|是| K[Boosting查询]
    J -->|否| L[Bool查询]
            </div>
            
            <div class="note mt-4">
                <p><strong><i class="fas fa-lightbulb mr-1"></i> 选择查询类型的建议：</strong></p>
                <ul class="list-disc pl-6 mt-2">
                    <li><strong>从简单开始：</strong> 除非有特殊需求，否则优先考虑使用 Bool 查询</li>
                    <li><strong>考虑查询目的：</strong> 明确是需要过滤文档还是需要影响评分</li>
                    <li><strong>关注数据类型：</strong> 对于嵌套对象数据，使用 Nested 查询</li>
                    <li><strong>性能优先：</strong> 如果只需过滤文档，使用 Constant Score 或 Bool 查询的 filter 子句</li>
                    <li><strong>复杂排序：</strong> 对于高级排序需求，考虑使用 Function Score 查询</li>
                </ul>
            </div>
        </section>
        
        <section id="performance" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-tachometer-alt mr-2"></i>9. 性能考量</h2>
            <p class="mb-4">
                在使用复合查询时，需要考虑以下性能相关的因素：
            </p>
            
            <h3 class="text-xl font-bold mb-3 text-cyan-500">9.1 查询类型与性能</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>过滤器优先：</strong> 尽可能使用 filter 而不是 must，因为过滤器查询可以被缓存，并且跳过了评分计算</li>
                <li><strong>避免过深的嵌套：</strong> 过度嵌套的 Bool 查询会增加复杂度和执行时间</li>
                <li><strong>限制 should 子句数量：</strong> 大量的 should 子句会降低查询性能</li>
                <li><strong>谨慎使用嵌套查询：</strong> Nested 查询相对更消耗资源，因为每个嵌套文档都会被单独索引</li>
                <li><strong>Function Score 成本：</strong> 复杂的评分函数可能会影响查询性能，特别是使用脚本时</li>
            </ul>
            
            <h3 class="text-xl font-bold mb-3 text-cyan-500">9.2 优化策略</h3>
            <ul class="list-disc pl-6 mb-4">
                <li><strong>合理使用 filter 缓存：</strong> 将频繁使用的过滤条件放在 filter 子句中</li>
                <li><strong>优化查询顺序：</strong> 将能过滤掉更多文档的条件放在前面</li>
                <li><strong>控制查询深度：</strong> 避免过多层次的嵌套查询</li>
                <li><strong>使用预计算字段：</strong> 对于复杂的评分逻辑，考虑在索引时预计算字段值</li>
                <li><strong>适当使用索引：</strong> 确保查询中使用的字段都已正确索引</li>
                <li><strong>分页优化：</strong> 使用 search_after 或 scroll API 代替深度分页</li>
            </ul>
            
            <div class="warning mt-4">
                <p><strong><i class="fas fa-exclamation-triangle mr-1"></i> 性能陷阱：</strong></p>
                <ul class="list-disc pl-6 mt-2">
                    <li><strong>大量的 must_not 和 should 子句</strong> 可能会显著降低查询性能</li>
                    <li><strong>使用通配符前缀（如 *term）</strong> 会导致无法使用索引</li>
                    <li><strong>过于复杂的脚本评分</strong> 可能成为性能瓶颈</li>
                    <li><strong>大数据集上的嵌套查询</strong> 可能导致内存使用激增</li>
                </ul>
            </div>
        </section>
        
        <section id="conclusion" class="mb-8">
            <h2 class="text-2xl font-bold mb-4 text-cyan-600"><i class="fas fa-flag-checkered mr-2"></i>10. 总结</h2>
            <p class="mb-4">
                Elasticsearch 的复合查询提供了强大的灵活性，允许我们构建复杂的查询逻辑来满足各种业务需求。我们已经详细介绍了各种复合查询类型，包括：
            </p>
            
            <ul class="list-disc pl-6 mb-4">
                <li><strong>Bool 查询：</strong> 使用布尔逻辑组合多个查询条件</li>
                <li><strong>Boosting 查询：</strong> 降低某些文档的相关性评分</li>
                <li><strong>Constant Score 查询：</strong> 为匹配文档分配固定评分</li>
                <li><strong>Dis Max 查询：</strong> 使用最佳匹配查询的评分</li>
                <li><strong>Function Score 查询：</strong> 通过自定义函数修改评分</li>
                <li><strong>Nested 查询：</strong> 查询嵌套对象数组</li>
            </ul>
            
            <p class="mb-4">
                选择合适的复合查询类型取决于具体的业务需求，包括数据结构、查询逻辑和性能要求。在实际应用中，这些查询类型往往会结合使用，形成更加复杂和强大的查询。
            </p>
            
            <div class="note mt-4">
                <p><strong><i class="fas fa-lightbulb mr-1"></i> 关键要点：</strong></p>
                <ul class="list-disc pl-6 mt-2">
                    <li>复合查询是构建复杂搜索逻辑的基础</li>
                    <li>理解不同复合查询类型的特点和适用场景</li>
                    <li>注意查询性能，选择最适合需求的查询类型</li>
                    <li>合理使用过滤器和评分机制</li>
                    <li>在复杂性和性能之间找到平衡点</li>
                </ul>
            </div>
            
            <p class="mt-4">
                通过掌握这些复合查询，你可以更好地利用 Elasticsearch 的搜索能力，为用户提供更加精准和个性化的搜索体验。
            </p>
        </section>
    </div>

    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        // Highlight active section based on scroll position
        window.addEventListener('scroll', function() {
            const sections = document.querySelectorAll('section');
            let currentSection = '';
            
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                const sectionHeight = section.clientHeight;
                if(pageYOffset >= (sectionTop - 200)) {
                    currentSection = section.getAttribute('id');
                }
            });
            
            const links = document.querySelectorAll('.toc-link');
            links.forEach(link => {
                link.classList.remove('active');
                if(link.getAttribute('href') === '#' + currentSection) {
                    link.classList.add('active');
                }
            });
        });

        // Initialize mermaid diagrams
        mermaid.initialize({
            startOnLoad: true,
            theme: 'neutral',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            }
        });
    </script>
</body>
</html>
